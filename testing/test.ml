(*Test Plan: We used a mix of manual and automated testing to ensure the 
  robustness of our backend. 

  *****************Automated (Dbquery, Search, Passwords)***********************
  We used OUnit2 specifically to test interaction with the Database in terms of 
  insertions, updates, and deletions. By performing operations using the in
  terfacing get and set functions in the Dbquery module, we thoroughly 
  checked that data were formatted correctly if acceptable and rejected if 
  formatted incorrectly. We directly assessed Dbquery and Search, as the 
  purpose of Db was to handle database table creation, which was not changed 
  throughout the development process; testing of it was handled manually. 
  The Server module was tested manually as well, because testing routes us
  ing OUnit2 presented challenges with request creation and running the test 
  suite and server concurrently.

  Due to the dynamicity and size of the search operation, only property-based
  tests were employed; the true output was thoroughly assessed with different
  manual inputs to Postman (detailed below).

  We used dummy inputs generated by a script in order to validate our data 
  insertion. However, in testing search, the program made live requests to the
  Zomato API.

  Types of testing: We used a mix of black box and glass box testing for the
  automatic portion. We created tests by using "make docs" and using the 
  generated documentation to ensure that specifications were met. We then 
  reviewed the actual implementation to ensure coverage of all branches. 
  We did not utilize randomized testing. 

  ************************Manual (Db, Server, Search)**************************
  We used Postman, an application for sending and receiving HTTP requests for 
  testing the server module. We confirmed that the insertion of new users, 
  voting, and performing surveys was reliable and that unique and primary key 
  constraints in the database led to the rejection of invalid requests.
  We also employed DB Browser for sqlite--a graphical application for viewing
  and interacting with sqlite ".db" files, which allowed us to visualize the
  database structure and test the raw SQL that was in our source code. The DB
  module was tested with a thorough, manual review of each table.
  Types of testing: We used a combination of both black-box and glass-box 
  testing for the manual portion. For black-box testing, we used the HTTP 
  interface to make sure that we got responses for all well-formed bodies and 
  routes (as documented). With glass-box testing, we were able to go 
  line-by-line and ensure that for every table definition that we executed,
  the proper constraints, types, and structures were applied. Since the 
  interface of Db does not expose any of its structure, we had to rely on 
  glass-box testing exclusively for it.
  Testing Approach: This manual testing approach demonstrates the correctness
  of the system since we were able to ensure that our HTTP requests are 
  successful and that the tables we created in sqlite3. Through the 
  implementation of both automated and manual testing alongside we ensure 
  the correctness of our system by implementing a wide 
  variety of testing that provide a significant number of normal and edge-case 
  inputs to our routes. After ensuring that our functions and routes are 
  successful individually, our testing plan ensures that they correctly come 
  together when testing our modules.
*)
open Lib
open Lib.Dbquery 
open OUnit2

(**[open_db] is evaluated when the module is first processed*)
let open_db = Lib.Dbquery.create_tables ()

(*Testing user functions*)
let make_user ?friends:(f = []) ?restrictions:(r = []) ?groups: (g = []) 
    id un pw n =
  {
    id = id;
    username = un; 
    password = pw; 
    name = n; 
    friends = f; 
    restrictions = r;
    groups = g;
    visited = []
  }

let make_group ?members:(m = []) ?voting:(v = false) ?top_5:(t5 = None) 
    ?top_pick:(t = None) id name host =
  {
    id = id;
    name = name;
    host_id = host;
    members = m; 
    voting_allowed = v;
    top_5 = t5;
    top_pick = t;
  }

let make_restriction id name =
  { 
    id = id;
    name = name;
  }

(*OUnit2 test creators*)
let test_equal ?compare:(cmp = ( = )) name exptd expr = 
  name >:: (fun _ -> assert_equal ~cmp:cmp exptd expr)

let test_passes name ?succ:(s = true) ins_func data = 
  let try_test ins_func data = 
    try match ins_func data with 
      | Some _ -> true 
      | None -> false 
    with _ -> false in
  name >:: (fun _ -> assert_equal s (try_test ins_func data)) 

(**[try_get get_func id] is false if an attempt to retrieve data with [id] 
   using get_func raises and exception. The resulting data are ignored.*)
let try_get name get_func id = 
  let success = begin
    try 
      match get_func id with 
      | _ -> true
    with 
      | Not_found -> true 
      | _ -> false end in
  test_equal name true success

(**ensures that the user matching [n] in the database matches the user 
   generated with [make_user]*) 
let test_user name id (u, p, n) = 
  (*add a user to the database*)
  let user = make_user id u (Bcrypt.hash p |> Bcrypt.string_of_hash) n in 
  test_equal name 
    {(get_user id) with password = p} {user with password = p}

(**[ins_user] curries the user insertion function to throw an error within
   the test instead of the definition *)
let ins_user (u, n, p) = 
  add_user u n p

(*definitions perform operations on the database at open; 8, 9 in suite*)
let users_1_thru_4 = () (*Admins*)
let user_5 = add_user "reetu" "Reetu123" "Reetu"
let user_6 = add_user "bigdroo" "Andrew1" "Andrew"
let user_7 = add_user "andrewo" "Andrew2" "Andrew"
let user_8 = add_user "zach" "Zach123" "Zachary"
let user_9 = add_user "johndoe" "Johnny1" "John"
let user_10 = add_user "janedoe" "Jane123" "Jane"
let user_11 = add_user "peterparker" "Peter1234" "Peter"
let user_12 = () (*("andrew1235", "Baa5j1", "Andrew")*)
let user_13 = () (*("nikkinikki", "Andrew1 ", "Michael")*)

let add_user_test = [
  (*validate existing insertions*)
  test_user "ensure that the first user added is correct, 1-indexing" 5
    ("reetu", "Reetu123", "Reetu");
  test_user "ensure that the 5th user is correct" 9
    ("johndoe", "Johnny", "John"); 
  test_user "ensure that all users have been added" 11
    ("peterparker", "Peter1234", "Peter");
  (*users 12 and 13*)
  (* test_passes "names can be shared"
    ~succ:true ins_user ("andrew1234", "Baa5j1", "Andrew"); *)
  test_passes "usernames must be unique"
    ~succ:false ins_user ("andrewosorio", "Andrew3", "John");
  (* test_passes "makes sure two people can have the same password"
    ~succ:true ins_user ("nikkinikki", "Andrew1", "Michael"); *)
  test_passes "username is incorrect"  
    ~succ:false ins_user ("", "Jane123", "Jane");
  test_passes "malformed name" ~succ:false ins_user 
    ("peterparker1", "Jane123", "");
]

let get_user_test = [
  try_get "valid user" get_user 1;
  try_get "ids that are out of bounds are handled" get_user 13;
  try_get "negative ids are not permitted" get_user ~-10;
  try_get "0th id is" get_user 0;
  try_get "min int" get_user min_int;
  try_get "max int" get_user max_int;
]

(*ensure validity of password requirements*)
let test_password name bool pw = test_equal name bool (Passwords.is_valid pw)

let password_test = [
  (*ensure passwords meet criteria*)
  test_password "password cannot be empty" false "";
  test_password "contains no capital letter" false "abcd123";
  test_password "numeric password" false "123135424354";
  test_password "password contains no numbers" false "Abcdefghi";
  test_password "missing lowercase password" false "ASD123";
  test_password "password less than seven characters" false "ab12";
  test_password "valid password" true "Abcde123";
]

let ins_friends (f1, f2) = add_friends f1 f2 

let test_friends ?are_friends:(ff = true) name f1 f2 = 
  let friends_1 = (get_user f1).friends in 
  let expr = if ff then List.mem f2 friends_1 
    else not (List.mem f2 friends_1) in
  name >:: (fun _ -> assert_bool "not friends" expr)

(*definitions perform operations on the database at open*)
let friends_1 = add_friends 5 6
let friends_2 = add_friends 6 7
let friends_3 = add_friends 7 8
let friends_4 = () (*(5, 8)*)
let friends_5 = () (*(5, 13)*)

let add_friends_test = [
  (*attempt new insertions*)
  (* test_passes "insert two valid friends" ~succ:true ins_friends (5, 8); 
  test_passes "friend first and last users" ~succ:true ins_friends (5, 13);
  test_friends ~are_friends:true "users are friends following insertion" 5 8;  *)
  test_passes "the same friendship, reversed" ~succ:false ins_friends (8, 5);
  test_passes "friendships are unique" ~succ:false ins_friends (5, 8);
  test_passes "cannot friend oneself" ~succ:false ins_friends (3, 3);
  test_friends ~are_friends:false "test that previous insert was blocked" 3 3;
]

let is_friend_test = [
  test_friends "test that users 6 and 7 are friends" 6 7;
  test_friends "test friend reciprocity" 7 6;
  test_friends ~are_friends:false "users that are not friends" 1 3;
  test_friends ~are_friends:false "one nonexistent user" 1 55;
]

let ins_group (g_id, u_id) = 
  join_group g_id u_id 

(**ensures that the group matching [n] in the database matches the user 
   generated with [make_group]*) 
let test_group ?is_eq:(eq = ( = )) ?members:(m = []) 
    ?voting:(v = false) ?top_5:(t5 = None) ?top_pick:(t = None) 
    name group_id n h = 
  let group = make_group ~members:m ~voting:v ~top_5:t5 
      ~top_pick:t group_id n h in
  test_equal ~compare:eq name (get_group group_id) group

let no_group_test = [
  test_passes "join group before creation" ~succ:false ins_group (1, 2); 
  test_passes "invalid user joins a group" ~succ:false ins_group (1, 14); 
]

let ins_group_info (g_name, h_id) = add_group_info g_name h_id

let group_1 = add_group_info "birthday party" 7
let group_2 = add_group_info "anniversary dinner" 5
let group_3 = add_group_info "lunch" 6 
let group_4 = add_group_info "taco tuesday" 5
let group_5 = () (*("birthday party", 2)*)
let group_6 = () (*("garden party", 2)*)

(*the total number of valid groups should be 6*)
let add_group_info_test = [
  (* validate existing insertions *)
  (* test_group "ensure that the details of group 1 are correct" 1 
    "birthday party" 7;
  test_group "ensure that the details of group 3 are correct" 3 
    "lunch" 6; *)
  test_group ~is_eq:( <> ) "group and host id not reversed" 2 
    "anniversary dinner" 1; 
  test_group ~is_eq:( <> ) "mismatched group id and details" 1 
    "lunch" 3;
  test_group ~is_eq:( <> ) "non existing group" 1 
    "dinner" 1;
  test_group ~is_eq:( <> ) "non existing host" 1 "birthday party" 0;
  (*attempt new insertions*)
  (* test_passes ~succ:true "same group name, different hosts allowed" 
    ins_group_info ("birthday party", 2); *)
  (* test_passes ~succ:true "one host can create two groups with different names" 
    ins_group_info ("garden party", 2); *)
  test_passes ~succ:false "one host cannot create two groups with the same name"
    ins_group_info ("birthday party", 3);
  test_passes ~succ:false "incorrect host_id cannot create group" 
    ins_group_info ("birthday party", 0);     
]

(**[ins_group_invite] inserts [u_id] into [g_id] by invitation of [h_id]*)
let ins_group_invite (g_id, u_id, h_id) = add_group_invites g_id u_id h_id

let invite_1 = add_group_invites 3 1 2
let invite_2 = add_group_invites 2 3 1
let invite_3 = add_group_invites 1 2 3
let invite_4 = () (*5, 1, 2*)
let invite_5 = () (*3, 1, 2*)

let group_invites_test = [  
  test_passes ~succ:true "insertion of a valid invite by admin" 
    ins_group_invite (5, 1, 2);
  test_passes ~succ:true "insertion of a valid invite by admin" 
    ins_group_invite (3, 1, 4);
  test_passes ~succ:false "ensures that nonexisting admin cannot send invites"
    ins_group_invite (1, 2, 0);
  test_passes ~succ:false "ensure invite cannot be sent twice to same memeber"
    ins_group_invite (1, 2, 3);
  test_passes ~succ:false "ensure cannot send invalid group"
    ins_group_invite (0, 1, 2);
  test_passes ~succ:false "ensure cannot send to invalid user"
    ins_group_invite (1, 0, 3);
]
(*group membership ids, hosts are inserted by default*)
let group_mem1 = () (*(1, 3)*)
let group_mem2 = () (*(2, 1)*)
let group_mem3 = () (*(3, 2)*)
let group_mem4 = () (*(4, 5)*)
let group_mem5 = () (*(5, 2)*)
let group_mem6 = () (*(6, 2)*)
let group_mem7 = join_group 3 1                      
let group_mem8 = join_group 2 3
let group_mem9 = join_group 1 3

let add_group_test = [
  (* test_group ~is_eq:( <> ) ~members:[2] 
        "ensures that the host counts as a member" 
        5 "birthday party" *)    
  (* test_passes ~succ:true "check regular addition to populated group" 
    ins_group (3, 4);
  test_passes ~succ:true "host of a group can join another group" 
    ins_group (5, 1);  *)
  test_passes ~succ:false "ensures invalid member cannot be added to group"
    ins_group (3, 0); 
  test_passes ~succ:false "test that user cannot be added to nonexisting group"
    ins_group (0, 3);
  test_passes ~succ:false "cannot add host to group" 
    ins_group (5, 2);
  test_passes ~succ:false "member cannot join same group"
    ins_group (3, 4);
] 

let get_group_test = [
  try_get "correctly returns a valid group" get_group 1;
  try_get "ensures that nonexisting group cannot be returned" get_group 0;
  try_get "negative groups are not permitted" get_group ~-10;
  try_get "min group" get_group min_int;
  try_get "max group" get_group max_int;
]

let is_member ?succ:(b = true) name g_id h_id = 
  let res = 
    try begin match List.mem g_id (get_user h_id).groups with 
      | bool -> bool
    end 
    with _ -> false in 
  test_equal name b res

let member_test = [
  is_member "correctly returns member is in group" 1 3;
  is_member "ensure member in add_group suite was inserted" 3 4;
  is_member ~succ: false "member that is not in a group" 1 5;
  is_member "check if nonexistent group contains an existing user" 0 3;
]

let test_restriction ?succ:(b = true) name rest_id rest_name = 
  let comp = if b then ( = ) else ( <> ) in
  test_equal ~compare:comp name (get_restriction_by_id rest_id) rest_name

(**Inserts a restriction using [ad_id] *)
let ins_restriction (ad_id, rest_name) = add_restrictions_index 
    ad_id rest_name

let del_restriction (ad_id, rest_name) = remove_restrictions_index 
    ad_id rest_name

let restriction_1 = add_restrictions_index 1 "Vegan"
let restriction_2 = add_restrictions_index 2 "dairy"
let restriction_3 = add_restrictions_index 3 "Gluten"
let restriction_4 = () (*("peanuts")*)

let change_restriction_test = [
  test_passes "insertion of a valid restriction by an admin" ins_restriction 
    (2, "peanuts");  
  test_passes "invalid restriction name" ~succ:false ins_restriction 
    (2, ""); 
  test_passes "duplicate restriction name" ~succ:false ins_restriction 
    (2, "Vegan");
  test_passes "case-insensitive restrictions are unique" ~succ:false  
    ins_restriction (3, "gluten");
  test_passes "insertion of restriction not by admin" ~succ:false 
    ins_restriction (8, "shellfish");
  (*test deletions*)
  test_passes "delete an existing restriction" ~succ:true del_restriction 
    (2, 4);
  test_passes "delete nonexistent restriction" ~succ:false ins_restriction 
    (2, "soy");
] 

let get_restrictions_test = [
  test_restriction ~succ:true "correctly returns a valid restriction" 
    1 "Vegan";
  test_restriction ~succ:true "case insensitive restriction"
    2 "Dairy";
  try_get "nonexistent restriction" get_restriction_by_id 15;
  try_get "min restriction" get_restriction_by_id min_int;
  try_get "max restriction" get_restriction_by_id max_int;
]

let test_preference ?succ:(b = true) name pref_id pref_name = 
  let comp = if b then ( = ) else ( <> ) in
  test_equal ~compare:comp name (get_preference_by_id pref_id) pref_name

let ins_pref (ad_id, pref_name) = add_preferences_index ad_id pref_name 

let del_pref (ad_id, pref_name) = remove_preferences_index ad_id pref_name 

let preferences_1 = add_preferences_index 1 "Takeout"
let preferences_2 = add_preferences_index 2 "Dog Friendly"
let preferences_3 = add_preferences_index 4 "Indoors"
let preferences_4 = () (*("peanuts")*)

let change_preferences_test = [
  test_preference ~succ:true 
    "check first preferences added to empty preferences" 1 "Takeout";
  test_preference ~succ:true "more than one person can add preference" 
    2 "Dog Friendly"; 
  test_passes ~succ:true "test that user can add preference" 
    ins_pref (1, "Takeout");
  test_passes ~succ:false "ensures invalid member cannot add to preferences"
    ins_pref (0, "Outdoors");
  test_passes ~succ:true "test that admin can delete preference"
    del_pref (1, 1);
  test_passes ~succ:false "test that invalid user cannot delete a preference"
    del_pref (0, 3);
  test_passes ~succ:false 
    "test that admins cannot delete nonexisting preferences" del_pref (3, 0); 
]

let get_preferences_test = [
  try_get "correctly returns the first preference id" get_preference_by_id 1;
  try_get "ensures that nonexisting admin cannot get preference" 
    get_preference_by_id 5;
  try_get "returns the minimum preference id" get_preference_by_id min_int;
  try_get "returns the maximum preference id" get_preference_by_id max_int;
]

let test_cuisine ?succ:(b = true) name c_id c_name = 
  let comp = if b then ( = ) else ( <> ) in
  test_equal ~compare:comp name (get_cuisine_by_id c_id) c_name

let ins_cuisine (ad_id, cuisine_id, cuisine_name) = 
  add_cuisine ad_id cuisine_id cuisine_name

(*[del_cuisine] does not require the cuisine name*)
let del_cuisine (ad_id, cuisine_id) = 
  remove_cuisine ad_id cuisine_id

let cuisine_1 = add_cuisine 1 55 "Italian"
let cuisine_2 = add_cuisine 4 73 "Mexican"
let cuisine_3 = add_cuisine 2 25 "Chinese"
let cuisine_4 = add_cuisine 3 1018 "Modern Indian"

let cuisines_test = [
  test_cuisine ~succ:true 
    "check first cuisine is added to empty cuisines" 55 "Italian";
  test_cuisine ~succ:true 
    "test that more than one cuisines can be added to cuisines" 73 "Mexican";
  test_passes ~succ:true "ensures that the first cuisine is inserted correctly" 
    ins_cuisine (1, 55, "Italian"); 
  test_passes ~succ:false "ensures that invalid cuisine cannot be added" 
    ins_cuisine (1, 25, "");
  test_passes ~succ:true "test that admin can delete cuisine" 
    del_cuisine (1, 55);
  test_passes ~succ:false "test that invalid cuisine cannot be deleted"
    del_cuisine (1, -1); 
]

let get_cuisine = [
  try_get "correctly returns a valid cuisine" get_cuisine_by_id 1;
  try_get "ensures that nonexisting cuisine cannot be returned" 
    get_cuisine_by_id ~-1;
  try_get "0th cuisine is" get_cuisine_by_id 0;
  try_get "min cuisine" get_cuisine_by_id min_int;
  try_get "max cuisine" get_cuisine_by_id max_int;
]

let del_group (u_id, g_id) = delete_group u_id g_id

(*both admins and hosts can delete groups*)
let delete_group_test = [
  test_passes "ensure that first group is deleted" del_group (1, 2);
  test_passes "delete already deleted group" ~succ:false del_group (2, 2);
  test_passes "nonexisting admin delete group" ~succ:false del_group (0, 3);
  test_passes "delete maximum group" ~succ:false del_group (4, max_int);
  test_passes "delete minimum group" ~succ:false del_group (2, min_int);
]

let kick_member (g_id, u_id, h_id) = delete_from_group g_id u_id h_id

let has_members (g_id, h_id) = List.mem h_id (get_group g_id).members

(*use [is_member] to assess whether a user has a group*)
let delete_from_group_test = [

]

let is_host (g_id, u_id) = (get_group g_id).host_id = u_id

let change_host (g_id, u_id, h_id) = reassign_host g_id u_id h_id 

let reassign_host_test = []

let rests_exist name ?survey:(s = true) grp_id = 
  let restaurants =   
    if s then (get_group grp_id).top_5 else (get_group grp_id).top_pick in 
  let result = 
    match restaurants with 
    | Some _ -> true
    | None -> false in 
  name >:: fun _ -> assert_bool "result was not determined" result

(* let submit_survey = calculate_survey  *)
(* let survey_1 = ans_survey  *)

let survey_test = []

let vote_exists grp_id = (get_group grp_id).top_5 

let voting_test = []

let search_test = []

let get_winner_test = []

let visited_test = []

let tests = "test suite for uPick" >::: List.flatten [
    add_user_test;
    get_user_test;
    password_test;
    add_friends_test;
    is_friend_test;
    no_group_test;
    add_group_info_test;
    add_group_test;
    get_group_test;
    (* member_test;
    change_restriction_test;
    get_restrictions_test;
    change_preferences_test;
    get_preferences_test;
    cuisines_test;
    group_invites_test;
    delete_group_test;
    visited_test;
    delete_from_group_test;
    reassign_host_test;
    survey_test;
    voting_test;
    search_test;
    get_winner_test;  *)
  ]

let _ = run_test_tt_main tests