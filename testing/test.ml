(*Test Plan: We used a mix of manual and automated testing to ensure the 
  robustness of our backend. 

  *****************Automated (Dbquery, Search, Passwords)***********************
  We used OUnit2 specifically to test interaction with the Database in terms of 
  insertions, updates, and deletions. By performing operations using the in
  terfacing get and set functions in the Dbquery module, we thoroughly 
  checked that data were formatted correctly if acceptable and rejected if 
  formatted incorrectly. We directly assessed Dbquery and Search, as the 
  purpose of Db was to handle database table creation, which was not changed 
  throughout the development process; testing of it was handled manually. 
  The Server module was tested manually as well, because testing routes us
  ing OUnit2 presented challenges with request creation and running the test 
  suite and server concurrently.

  Due to the dynamicity and size of the search operation, only property-based
  tests were employed; the true output was thoroughly assessed with different
  manual inputs to Postman (detailed below).

  We used dummy inputs generated by a script in order to validate our data 
  insertion. However, in testing search, the program made live requests to the
  Zomato API.

  Types of testing: We used a mix of black box and glass box testing for the
  automatic portion. We created tests by using "make docs" and using the 
  generated documentation to ensure that specifications were met. We then 
  reviewed the actual implementation to ensure coverage of all branches. 
  We did not utilize randomized testing. 

  ************************Manual (Db, Server, Search)**************************
  We used Postman, an application for sending and receiving HTTP requests for 
  testing the server module. We confirmed that the insertion of new users, 
  voting, and performing surveys was reliable and that unique and primary key 
  constraints in the database led to the rejection of invalid requests.
  We also employed DB Browser for sqlite--a graphical application for viewing
  and interacting with sqlite ".db" files, which allowed us to visualize the
  database structure and test the raw SQL that was in our source code. The DB
  module was tested with a thorough, manual review of each table.
  Types of testing: We used a combination of both black-box and glass-box 
  testing for the manual portion. For black-box testing, we used the HTTP 
  interface to make sure that we got responses for all well-formed bodies and 
  routes (as documented). With glass-box testing, we were able to go 
  line-by-line and ensure that for every table definition that we executed,
  the proper constraints, types, and structures were applied. Since the 
  interface of Db does not expose any of its structure, we had to rely on 
  glass-box testing exclusively for it.
  Testing Approach: This manual testing approach demonstrates the correctness
  of the system since we were able to ensure that our HTTP requests are 
  successful and that the tables we created in sqlite3. Through the 
  implementation of both automated and manual testing alongside we ensure 
  the correctness of our system by implementing a wide 
  variety of testing that provide a significant number of normal and edge-case 
  inputs to our routes. After ensuring that our functions and routes are 
  successful individually, our testing plan ensures that they correctly come 
  together when testing our modules.
*)
open Lib
open Lib.Dbquery 
open OUnit2

(**[open_db] is evaluated when the module is first processed*)
let open_db = Lib.Dbquery.create_tables ()

(*Testing user functions*)
let make_user ?friends:(f = []) ?restrictions:(r = []) ?groups: (g = []) 
    id un pw n =
  {
    id = id;
    username = un; 
    password = pw; 
    name = n; 
    friends = f; 
    restrictions = r;
    groups = g;
    visited = []
  }

let make_group ?members:(m = []) ?voting:(v = false) ?top_5:(t5 = None) 
    ?top_pick:(t = None) id name host =
  {
    id = id;
    name = name;
    host_id = host;
    members = m; 
    voting_allowed = v;
    top_5 = t5;
    top_pick = t;
  }

let make_restriction id name =
  { 
    id = id;
    name = name;
  }

(*OUnit2 test creators*)

let test_equal ?compare:(cmp = ( = )) name exptd expr = 
  name >:: (fun _ -> assert_equal ~cmp:cmp exptd expr)


let test_passes name ?succ:(s = true) ins_func data = 
  let try_test ins_func data = 
    try match ins_func data with 
      | Some _ -> true 
      | None -> false 
    with _ -> false in
  name >:: (fun _ -> assert_equal s (try_test ins_func data)) 

(**[try_get get_func id] is false if an attempt to retrieve data with [id] 
   using get_func raises and exception. The resulting data are ignored.*)
let try_get name get_func id = 
  let success = begin
    try 
      match get_func id with 
      | _ -> true
    with 
      _ -> false end in
  test_equal name true success

(**ensures that the user matching [n] in the database matches the user 
   generated with [make_user]*) 
let test_user name id (u, p, n) = 
  (*add a user to the database*)
  let user = make_user id u (Bcrypt.hash p |> Bcrypt.string_of_hash) n in 
  test_equal name 
    {(get_user id) with password = p} {user with password = p}

(**[ins_user] curries the user insertion function to throw an error within
   the test instead of the definition *)
let ins_user (u, n, p) = 
  add_user u n p

(*definitions perform operations on the database at open; 8, 9 in suite*)
let users1thru4 = () (*Admins*)
let user5 = add_user "reetu" "Reetu123" "Reetu"
let user6 = add_user "bigdroo" "Andrew1" "Andrew"
let user7 = add_user "andrewo" "Andrew2" "Andrew"
let user8 = add_user "zach" "Zach123" "Zachary"
let user9 = add_user "johndoe" "Johnny1" "John"
let user10 = add_user "janedoe" "Jane123" "Jane"
let user11 = add_user "peterparker" "Peter1234" "Peter"
let user12 = () (*("andrew1235", "baa5j1", "Andrew")*)
let user13 = () (*("nikkinikki", "Andrew1 ", "Michael")*)

let add_user_test = [
  (*validate existing insertions*)
  test_user "ensure that the first user added is correct, 1-indexing" 5
    ("reetu", "Reetu123", "Reetu");
  test_user "ensure that the 5th user is correct" 9
    ("johndoe", "Johnny", "John"); 
  test_user "ensure that all users have been added" 11
    ("peterparker", "Peter1234", "Peter");
  (*users 12 and 13*)
  test_passes "names can be shared"
    ~succ:true ins_user ("andrew1235", "baa5j1", "Andrew");
  test_passes "makes sure two people can have the same password"
    ~succ:true ins_user ("nikkinikki", "Andrew1 ", "Michael");
  test_passes "usernames must be unique"
    ~succ:false ins_user ("andrewosorio", "Andrew3", "John");
  test_passes "username is incorrect"  ~succ:false ins_user 
    ("", "Jane123", "Jane");
  test_passes "malformed name" ~succ:false ins_user 
    ("peterparker", "Jane123", "");
]

let get_user_test = [
  try_get "valid user" get_user 1;
  try_get "ids that are out of bounds are handled" get_user 13;
  try_get "negative ids are not permitted" get_user ~-10;
  try_get "0th id is" get_user 0;
  try_get "min int" get_user min_int;
  try_get "max int" get_user max_int;
]

(*ensure validity of password requirements*)
let test_password name bool pw = test_equal name bool (Passwords.is_valid pw)

let password_test = [
  (*ensure passwords meet criteria*)
  test_password "password cannot be empty" false "";
  test_password "contains no capital letter" false "abcd123";
  test_password "numeric password" false "123135424354";
  test_password "password contains no numbers" false "Abcdefghi";
  test_password "missing lowercase password" false "ASD123";
  test_password "password less than seven characters" false "ab12";
  test_password "valid password" true "Abcde123";
]

let ins_friends (f1, f2) = add_friends f1 f2 

let test_friends ?are_friends:(ff = true) name f1 f2 = 
  let friends_1 = (get_user f1).friends in 
  let expr = if ff then List.mem f2 friends_1 
    else not (List.mem f2 friends_1) in
  name >:: (fun _ -> assert_bool "not friends" expr)

(*definitions perform operations on the database at open*)
let friends1 = add_friends 5 6
let friends2 = add_friends 6 7
let friends3 = add_friends 7 8
let friends4 = () (*(5, 8)*)
let friends5 = () (*(5, 13)*)

let add_friends_test = [
  (*attempt new insertions*)
  test_passes "insert two valid friends" ~succ:true ins_friends (5, 8);
  test_passes "friend first and last users" ~succ:true ins_friends (5, 13);
  test_friends ~are_friends:true "users are friends following insertion" 5 8;
  test_passes "the same friendship, reversed" ~succ:false ins_friends (8, 5);
  test_passes "friendships are unique" ~succ:false ins_friends (5, 8);
  test_passes "cannot friend oneself" ~succ:false ins_friends (3, 3);
  test_friends ~are_friends:false "test that previous insert was blocked" 3 3;
]

let is_friend_test = [
  test_friends "test that users 6 and 7 are friends" 6 7;
  test_friends "test friend reciprocity" 7 6;
  test_friends ~are_friends:false "users that are not friends" 1 3;
  test_friends ~are_friends:false "one nonexistent user" 1 55;
]

let ins_group (g_id, u_id) = 
  join_group g_id u_id 

(**ensures that the group matching [n] in the database matches the user 
   generated with [make_group]*) 
let test_group ?is_eq:(eq = ( = )) ?members:(m = []) 
    ?voting:(v = false) ?top_5:(t5 = None) ?top_pick:(t = None) 
    name group_id n h = 
  let group = make_group ~members:m ~voting:v ~top_5:t5 
      ~top_pick:t group_id n h in
  test_equal ~compare:eq name (get_group group_id) group

let no_group_test = [
  test_passes "join group before creation" ~succ:false ins_group (1, 2); 
  test_passes "invalid user joins a group" ~succ:false ins_group (1, 14); 
]

let ins_group_info (g_name, h_id) = add_group_info g_name h_id

let group_1 = add_group_info "birthday party" 3
let group_2 = add_group_info "anniversary dinner" 1
let group_3 = add_group_info "lunch" 2 
let group_4 = add_group_info "taco tuesday" 5
let group_5 = () (*("birthday party", 2)*)
let group_6 = () (*("garden party", 2)*)

(*the total number of valid groups should be 6*)
let add_group_info_test = [
  (* validate existing insertions *)
  test_group "ensure that the details of group 1 are correct" 1 
    "birthday party" 3;
  test_group "ensure that the details of group 3 are correct" 3 
    "lunch" 2;
  test_group ~is_eq:( <> ) "group and host id not reversed" 2 
    "anniversary dinner" 1; 
  test_group ~is_eq:( <> ) "mismatched group id and details" 1 
    "lunch" 3;
  test_group ~is_eq:( <> ) "non existing group" 1 
    "dinner" 1;
  test_group ~is_eq:( <> ) "non existing host" 1 "birthday party" 0;
  (*attempt new insertions*)
  test_passes ~succ:true "same group name, different hosts allowed" 
    ins_group_info ("birthday party", 2);
  test_passes ~succ:true "one host can create two groups with different names" 
    ins_group_info ("garden party", 2);
  test_passes ~succ:false "one host cannot create two groups with the same name"
    ins_group_info ("birthday party", 3);
  test_passes ~succ:false "incorrect host_id cannot create group" 
    ins_group_info ("birthday party", 0);    
]

(*group membership ids, hosts are inserted by default*)
let group_mem1 = () (*(1, 3)*)
let group_mem2 = () (*(2, 1)*)
let group_mem3 = () (*(3, 2)*)
let group_mem4 = () (*(4, 5)*)
let group_mem5 = () (*(5, 2)*)
let group_mem6 = () (*(6, 2)*)
let group_mem7 = join_group 3 1
let group_mem8 = join_group 2 3
let group_mem9 = join_group 1 2

let add_group_test = [
  (* test_group ~is_eq:( <> ) ~members:[2] 
     "ensures that the host counts as a member" 
     5 "birthday party" 2;  *)
  test_passes ~succ:true "check regular addition to populated group" 
    ins_group (3, 4);
  test_passes ~succ:true "host of a group can join another group" 
    ins_group (5, 2); 
  test_passes ~succ:false "ensures invalid member cannot be added to group"
    ins_group (3, 0); 
  test_passes ~succ:false "test that user cannot be added to nonexisting group"
    ins_group (0, 3);
  test_passes ~succ:false "cannot add host to group" 
    ins_group (5, 2);
  test_passes ~succ:false "member cannot join same group"
    ins_group (3, 4);
] 

let get_group_test = [
  try_get "correctly returns a valid group" get_group 1;
  try_get "ensures that nonexisting group cannot be returned" get_group 0;
  try_get "negative groups are no permitted" get_group ~-10;
  try_get "min group" get_group min_int;
  try_get "max group" get_group max_int;
]

let test_member ?succ:(b = true) name g_id h_id = 
  let res = 
    try begin match List.mem g_id (get_user h_id).groups with 
      | _ -> true
    end 
    with _ -> false in 
  test_equal name b res

let is_member_test = [
  test_member "correctly returns member is in group" 1 3;
  test_member "ensure member in add_group suite was inserted" 6 2;
  test_member "correctly returns member is in group" 1 3;
  test_member "correctly returns member is in group" 1 3;
  test_member "correctly returns member is in group" 1 3;
]

(**Inserts a restriction using [ad_id] *)
let ins_restriction (ad_id, rest_name) = add_restrictions_index 
ad_id rest_name

let restriction_1 = add_restrictions_index 1 "Vegan"
let restriction_2 = add_restrictions_index 2 "dairy"
let restriction_3 = add_restrictions_index 3 "Gluten"

let add_restriction_test = [
  test_passes "insertion of a valid restriction by an admin" ins_restriction 
  (2, "peanuts"); 
  test_passes "invalid restriction name" ~succ:false ins_restriction 
    (2, "");
  test_passes "duplicate restriction name" ~succ:false ins_restriction 
  (2, "Vegan");
  test_passes "case-insensitive restrictions are unique" ~succ:false  
  ins_restriction (3, "gluten");
  test_passes "insertion of restriction not by admin" ~succ:false 
  ins_restriction (8, "shellfish");
]

let get_restrictions_test = []
(* let set_restriction_test = [
  test_passes ~succ:true "new restriction" 2;
] *)

let add_preferences_test = []

let get_preferences_test = []

let cuisines_test = []

let group_invites_test = []

let delete_group_test = []

let visited_test = []

let delete_from_group_test = []

let reassign_host_test = []

(* let rests_exist name ?survey:(s = true) grp_id = 
  let restaurants =   
    if s then (get_group grp_id).top_5 else (get_group grp_id).top_5 in failwith "unimplemented" *)
    

let survey_test = []

let vote_exists grp_id = (get_group grp_id).top_5 

let voting_test = []

let search_test = []

let get_winner_test = []

let tests = "test suite for uPick" >::: List.flatten [
    no_group_test;
    add_user_test;
    get_user_test;
    password_test;
    add_friends_test;
    is_friend_test;
    add_group_info_test;
    add_group_test;
    get_group_test;
    is_member_test;
    add_restriction_test;
    get_restrictions_test;
    add_preferences_test;
    get_preferences_test;
    cuisines_test;
    group_invites_test;
    delete_group_test;
    visited_test;
    delete_from_group_test;
    reassign_host_test;
    survey_test;
    voting_test;
    search_test;
    get_winner_test;
  ]

let _ = run_test_tt_main tests